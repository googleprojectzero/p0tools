# CoreAudio Exploit POC (macOS Sequoia)

**Disclaimer: This code is provided for educational and research purposes only. The author is not responsible for any damage to your system, data loss, or any misuse of this information. Use at your own risk. Please make sure to read the "Important Warnings" section below.**

## Overview

This repository contains a Proof-of-Concept (POC) exploit targeting a Type Confusion vulnerability ([CVE-2024-54529](https://project-zero.issues.chromium.org/issues/372511888)) in `coreaudiod`. The vulnerability was fixed on December 11, 2024, with the release of macOS Sequoia 15.2, Sonoma 14.7.2, and Ventura 13.7.2. This specific exploit was developed and tested on macOS Sequoia 15.0.1. The exploit utilizes a heap spray and ROP chain to achieve code execution within the privileged `coreaudiod` process. This can be leverage for both privilege escalation and sandbox escapes.

The successful execution of this exploit demonstrates writing a file to `/Library/Preferences/Audio/malicious.txt`.

## Technical Details

This exploit employs a chain of primitives to turn a Type Confusion into code execution:

1.  **Uninitialized Memory:** The vulnerability relies on `ngne` objects having uninitialized memory (specifically a 6-byte gap) at offset `0x68`.
2.  **Heap Feng Shui via Plists:** We use `HALS_Object_SetPropertyData_DPList` to spray the heap with controlled data. By constructing large nested Property Lists (plists) containing `CFString` and `CFArray` objects, we control the memory layout. This data is serialized to disk at `/Library/Preferences/Audio/com.apple.audio.DeviceSettings.plist`.
3.  **Forced Restart Strategy:** `coreaudiod` cleans `malloc_tiny` zones but not `malloc_small` zones on allocation. To target the `ngne` objects (which are allocated in `malloc_small` only at startup), we intentionally crash `coreaudiod`.
4.  **Race/Reclaim:** On restart, `coreaudiod` deserializes our massive plist, allocating memory for it, and then immediately frees it. The startup routine then allocates `ngne` objects, which hopefully reclaim the just-freed memory containing our controlled pointers.
5.  **Pointer Chain & ROP:** The uninitialized memory at offset `0x68` now points to our controlled data, effectively creating a fake vtable. When the vulnerability is triggered, the program jumps to our ROP chain (encoded as UTF-16 string data to avoid validation issues), creating the target file.

## Further Reading

For a deep dive into the research behind this exploit, please refer to the following blog posts:

- **Part I (Fuzzing):** [Breaking the Sound Barrier: Part I - Fuzzing CoreAudio](https://projectzero.google/2025/05/breaking-sound-barrier-part-i-fuzzing.html)
- **Part II (Exploitation):** [Breaking the Sound Barrier: Part II - Exploiting CVE-2024-54529](https://TBD)

## Prerequisites

- **macOS Version:** Tested on macOS Sequoia 15.0.1.
- **SIP:** While developed on a system with SIP disabled for debugging, the primitives used are intended to work within the constraints of the hardened runtime, subject to specific sandbox allowances.
- **Dependencies:** Python 3, Xcode Command Line Tools (for compilation).

## Usage

The main entry point is `run_exploit.py`. This script manages the entire exploitation lifecycle: heap grooming, service restarting, and the repeated triggering of the race condition.

```bash
# Clean previous builds and compile the exploit binary
make exploit

# Run the exploit runner
./run_exploit.py
```

### What Happens?

1.  **Backup:** The script automatically backs up your current audio configuration (`/Library/Preferences/Audio/com.apple.audio.DeviceSettings.plist`) to `default-plist.plist` in the current directory.
2.  **Heap Grooming:** It performs a massive heap spray (creating thousands of dummy audio objects) to prepare the memory layout.
3.  **Service Reload:** It intentionally crashes `coreaudiod` once to force it to reload with the sprayed configuration.
4.  **Exploit Loop:** It continuously attempts to trigger the UAF vulnerability until the ROP chain successfully executes.

## ⚠️ Important Warnings

**1. Audio Device Spam:**
Running this exploit will create a **massive number of dummy audio devices** on your system as part of the heap grooming process. You may experience audio unresponsiveness or latency until you perform the recovery steps below.

**2. Recovery:**
The script is designed to handle this, but if your audio system behaves strangely after running the exploit, you can restore your original state:

*   **Automatic Backup:** The script saves your original state to `default-plist.plist`.
*   **Manual Reset:** A helper script is provided to clear the clutter. Run it with `sudo` to restore the clean state:
    ```bash
    sudo ./reset-devices.sh
    ```

**3. System Stability:**
This is a userland exploit involving system daemons. While unlikely to panic the kernel directly, crashing `coreaudiod` repeatedly may cause temporary audio loss or system instability.

## Code Structure

- `run_exploit.py`: The Python orchestration script. Handles state management, backups, and looping.
- `exploit.mm`: The C++ source code for the exploit binary. Handles the low-level Mach IPC messages, object creation, and memory spraying.
- `build_rop.py`: Python script to generate the ROP chain payload (`rop_payload.bin`). You'll need to find the correct runtime addresses for these gadgets, and do so again every time the system restarts.

## License

This software is open-source and provided "as is", without warranty of any kind.
